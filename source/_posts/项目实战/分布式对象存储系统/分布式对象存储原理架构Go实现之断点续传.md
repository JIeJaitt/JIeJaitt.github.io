---
title: 分布式对象存储原理架构Go实现之断点续传
date: 2022-03-07T10:29:30+08:00
categories: 项目实战
tags: [Go,分布式,对象存储]
excerpt: 本博客暂不显示摘要，请大家谅解
abbrlink: breakpoint-resume-upload
toc: true
sticky:
---

我们在上一章介绍了数据冗余技术，并利用RS纠删码实现了数据冗余和即时修复。本章我们要在此基础上实现断点续传功能。断点续传功能分两部分，分别是断点下载和断点上传。

## 为什么对象存储需要支持断点续传

在实验室的理想环境里网络永远通畅，对象存储系统并不需要断点续传这个功能。但在现实世界，对象存储服务在数据中心运行，而客户端在客户本地机器上运行，它们之间通过互联网连接。互联网的连接速度慢且不稳定，有可能由于网络故障导致断开连接。在客户端上传或下载一个大对象时，因网络断开导致上传下载失败的概率就会变得不可忽视。为了解决这个问题，对象存储服务必须提供断点续传功能，允许客户端从某个检查点而不是从头开始上传或下载对象。

### 断点下载流程

断点下载的实现非常简单，客户端在GET对象请求时通过设置Range头部来告诉接口服务需要从什么位置开始输出对象的数据，见图6-1。

接口服务的处理流程在生成对象流之前和上一章没有任何区别，但是在成功打开了对象数据流之后，接口服务会额外调用 rs.RSGetStream.Seek 方法跳至客户端请求的位置，然后才开始输出数据。

<img width="665" alt="断点下载流程" src="https://github.com/JIeJaitt/goDistributed-Object-storage/assets/77219045/67ffd48c-970a-4153-91ab-e8b1a4e1fa4b">

### 断点上传流程

断点上传的流程则要比断点下载复杂得多，这是由HTTP服务的特性导致的。客户端在下载时并不在乎数据的完整性，一旦发生网络故障，数据下到哪算哪，下次继续从最后下载的数据位置开始续传就可以了。

但是对于上传来说，接口服务会对数据进行散列值校验，当发生网络故障时，如果上传的数据跟期望的不一致，那么整个上传的数据都会被丢弃。所以断点上传在一开始就需要客户端和接口服务做好约定，使用特定的接口进行上传，见图6-2。

客户端在知道自己要上传大对象时就主动改用对象POST接口，提供对象的散列值和大小。接口服务的处理流程和上一章处理对象PUT一样，搜索6个数据服务并分别POST临时对象接口。数据服务的地址以及返回的uuid会被记录在一个token里返回给客户端。

客户端POST对象后会得到一个token。对token进行PUT可以上传数据，见图6-3。在上传时客户端需要指定range头部来告诉接口服务上传数据的范围。接口服务对token进行解码，获取6个分片所在的数据服务地址以及uuid,分别调用PATCH将数据写入6个临时对象。

<img width="723" alt="对象POST接口" src="https://github.com/JIeJaitt/goDistributed-Object-storage/assets/77219045/05d90532-14f6-4140-b6ee-a15ee292a32f">

<img width="750" alt="用PUT方法访问token上传数据" src="https://github.com/JIeJaitt/goDistributed-Object-storage/assets/77219045/3eec8ac5-5141-4bb6-a05d-76df63b11266">

通过PUT上传的数据并不一定会被接口服务完全接收。我们在第5章已经知道，经过RS分片的数据是以块的形式分批写入4个数据片的，每个数据片一次写入8000字节，4个数据片一共写入32000字节。所以除非是最后一批数据，否则接口服务只接收32000字节的整数倍进行写入。这是一个服务端的行为逻辑，我们不能要求客户端知道接口服务背后的逻辑，所以接口服务必须提供token的HEAD操作，让客户端知道服务端上该token目前的写入进度，见图6-4。

<img width="644" alt="用HEAD方法访问token获取当前已上传了多少数据" src="https://github.com/JIeJaitt/goDistributed-Object-storage/assets/77219045/dc2e6232-51cc-493e-9a2c-3568a6f8c78c">

客户端每次用PUT方法访问token之前都需要先用HEAD方法获取当前已上传了多少数据。接口服务对token进行解码，获取6个分片所在的数据服务地址以及uuid,仅对第一个分片调用HEAD获取该分片当前长度，将这个数字乘以4，作为Content-Length响应头部返回给客户端。

### 接口服务的REST接口
首先，接口服务的objects接口GET方法新增了Range请求头部，用于告诉接口服务需要的对象数据范围。
```bash
GET /objects/<object_name>
```
请求头部
- `Range:bytes=<first>-`
响应头部
- `Content-Range:bytes <first>-<size>/<size>`

响应正文
- 从first开始的对象内容
Range请求头部定义在RFC7233中，是HTTP/1.1协议的一部分。给GET请求加上Range头部意味着这个请求期望的只是全体数据的一个或多个子集。Range请求主要支持以字节为单位的byte Range(虽然协议本身也支持其他自定义的Range单位，但是如果实现者没有在LANA申请注册这个自定义的单位，那么就只有自己写的客户端和服务端之间可以互相理解)，byte range的格式是固定字符串“bytes=”开头，后面跟上一个或多个数字的范围，由逗号分隔。假设我们的整体数据是10000字节，那么合法的byte range格式可以有以下几个例子：

- 请求最后500个字节(9500~9999)。
bytes=-500
或
bytes=9500-
- 请求第一个和最后一个字节（字节0和9999）。
bytes=0-0,-1
- 其他几个合法但不常见的请求第500~999个字节的格式。
bytes=500-600,601-999
bytes-=500-700,601-999

本书的对象存储系统实现的格式是`bytes=<first>-`。客户端通过指定first的值告诉接口服务下载对象的数据范围，接口服务返回的数据从first开始，first之前的对象数
据会在服务端被丢弃。根据Range请求的协议规范，接口服务需要返回HTTP错误代码`206 Partial Content`,并设置Content-Range响应头部告知返回数据的范围`<frst>-<size>/<size>`,其中`<first>`是客户端要求的起始位置，`<size>`是对象的大小。

objects接口还新增了POST方法，用于创建token。
`POST /objects/<object name>`
请求头部
- Digest::SHA-256=<对象散列值的Base64编码>
- Size:<对象内容的长度>
响应头部
- Location:<访问temp/token的URI>
token被放在Location头部返回给客户端，客户端拿到后可以直接访问该URI。
除了objects接口发生的改变以外，接口服务还新增temp接口。
`HEAD /temp/<token>`
响应头部
- `Content-Length:<token当前的上传字节数>`
`PUT /temp/<token>`
请求头部
- `Range:bytes=<first>-<last>`
请求正文
- 对象的内容，字节范围为first~last
客户端通过Range头部指定上传的范围，first必须跟token当前的上传字节数一致，否则接口服务会返回`416 Range Not Satisfiable`。如果上传的是最后一段数据，`<last>`为空。

### 数据服务的REST接口

数据服务的temp接口新增了HEAD和GET两个方法，HEAD方法用于获取某个分片临时对象当前的大小；而GET方法则用于获取临时对象的数据。
`HEAD /temp/<uuid>`
响应头部
- Content-Length:<临时对象当前的上传字节数>
`GET /temp/<uuid>`
响应正文
- 临时对象的内容
客户端将对象所有的数据上传完毕之后，接口服务需要调用这个方法从数据服务读取各分片临时对象的内容并进行数据校验，只有在验证了对象的散列值符合预期的情况下，服务端才认为该对象的上传是成功的，进而将临时对象转正。

## G0语言实现
### 接口服务