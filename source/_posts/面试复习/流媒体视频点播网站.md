---
title: 流媒体视频点播网站
excerpt: 本博客暂不显示摘要，请大家谅解
abbrlink: 9fd5a35f
toc: true
date: 2023-03-08 11:46:28
categories: 期末考试
tags: 期末考试
sticky:
---

https://blog.csdn.net/weixin_52723461/article/details/120277314?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22120277314%22,%22source%22:%22weixin_52723461%22%7D

https://coding.imooc.com/class/227.html#Anchor

代码仓库：https://github.com/JIeJaitt/goStreaming-on-demand-services

个人优势；不限城市可以立即到岗提前入职；热爱开源熟悉Github仓库协作流程


## 数据表是怎么实现的




## 我看你说你测了QPS，怎么测的？最高能承受多少QPS？

本来我是想用Go语言自带的Benchmark来做基准测试的，但是后面我找到一个更方便的http压测工具————wrk，我就用wrk进行压测了，没有测过最高QPS，1000QPS的系统在一段时间内被100个左右的人同时使用了应该没问题，我当时觉得够了，而且我的系统还不完善，后面可能考虑加入redis之类的，性能应该能提升更多，而且视频网站的话我们还可以做本地缓存，这样用户体验会更好。

对于每种测试场景，我都设置了相同的压测参数，例如：

- 持续时间：2分钟
- 并发用户数：100
- 每秒请求次数（RPS）逐步提升：从100开始，每20秒增加100，直至系统达到其极限或保持一定的QPS水平。

```bash
wrk -t12 -c400 -d30s http://127.0.0.1:8080/api/session
```

## 你说你使用使用 sync.Map 在内存中缓存高频访问用户的 Session数据，那假如内存不够用了怎么办？

1、缓存淘汰之类的，`最近最少使用（LRU）`：淘汰最长时间未被访问的数据。这要求跟踪每个缓存项的访问历史，淘汰那些最少被访问的项。`先进先出（FIFO）`：淘汰最先加入缓存的数据。这种策略比较简单，但可能会淘汰掉仍然高频访问的数据。`基于时间的过期策略`：为每个缓存项设置一个过期时间，一旦过期就从缓存中移除。这种策略适合于那些数据访问模式随时间变化较大的应用。

然后我们还可以监控内存使用情况，并根据当前的内存压力动态调整缓存的大小。当检测到内存使用接近上限时，可以主动减少缓存中的数据项，比如通过删除访问频率较低的项或者最早加入缓存的项。

如果单个节点的内存容量不足以支持当前的缓存需求，可以考虑将服务水平扩展到多个节点。通过分布式缓存方案，如Redis或Memcached，将缓存数据分布在多个服务器上，可以有效缓解单个服务器内存不足的问题。

内存和缓存监控
定期监控内存和缓存的使用情况，这对于早期发现潜在的内存不足问题非常关键。通过监控，我们可以及时调整缓存策略或进行资源扩展，以防止系统因内存耗尽而出现性能问题或崩溃。

使用磁盘备份
对于那些不经常访问但仍然需要保留的数据，可以考虑将其从内存中移动到磁盘上。虽然这会增加访问这部分数据的延迟，但可以作为一种权衡，以确保系统的稳定性和响应性。

通过实施上述策略，我能够确保即使在内存受限的情况下，也能有效管理缓存，并保持系统的高性能和稳定运行。这需要对系统的运行状况有持续的监控和调整，以适应不断变化的负载和数据访问模式。


## 说一下session、cookie、token的区别

`Session`、`Cookie`和`Token`是在网络应用中处理用户状态和身份验证的三种不同技术。它们各自有不同的用途和工作机制：

- **存储位置**：Cookie存储在客户端浏览器上，Session信息存储在服务器上，Token虽然由服务器生成但通常存储在客户端。
- **安全性**：Token设计用于在不同服务间安全传递信息，通常具有更好的安全特性（如可以加密）。Session ID如果被截获，攻击者可能会进行会话劫持。Cookie也可能遭到CSRF（跨站请求伪造）等攻击。
- **状态**：Session是有状态的，服务器需要存储会话数据；而Token通常用于实现无状态认证机制，服务器不需要保存用户状态。

使用这些技术时，应根据应用的安全需求、性能考虑以及用户体验来选择最合适的方案。
