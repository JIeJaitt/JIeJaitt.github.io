---
title: 流媒体视频点播网站
excerpt: 本博客暂不显示摘要，请大家谅解
abbrlink: 9fd5a35f
toc: true
date: 2023-03-08 11:46:28
categories: 期末考试
tags: 期末考试
sticky:
---

https://blog.csdn.net/weixin_52723461/article/details/120277314?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22120277314%22,%22source%22:%22weixin_52723461%22%7D

https://coding.imooc.com/class/227.html#Anchor

代码仓库：https://github.com/JIeJaitt/goStreaming-on-demand-services

个人优势；不限城市可以立即到岗提前入职；热爱开源熟悉Github仓库协作流程


## 我看你说你测了QPS，怎么测的？最高能承受多少QPS？

本来我是想用Go语言自带的Benchmark来做基准测试的，但是后面我找到一个更方便的http压测工具————wrk，我就用wrk进行压测了，没有测过最高QPS，1000QPS的系统在一段时间内被100个左右的人同时使用了应该没问题，我当时觉得够了，而且我的系统还不完善，后面可能考虑加入redis之类的，性能应该能提升更多，而且视频网站的话我们还可以做本地缓存，这样用户体验会更好。

对于每种测试场景，我都设置了相同的压测参数，例如：

- 持续时间：2分钟
- 并发用户数：100
- 每秒请求次数（RPS）逐步提升：从100开始，每20秒增加100，直至系统达到其极限或保持一定的QPS水平。

```bash
wrk -t12 -c400 -d30s http://127.0.0.1:8080/api/session
```

## 你说你使用使用 sync.Map 在内存中缓存高频访问用户的 Session数据，那假如内存不够用了怎么办？

1、缓存淘汰之类的，`最近最少使用（LRU）`：淘汰最长时间未被访问的数据。这要求跟踪每个缓存项的访问历史，淘汰那些最少被访问的项。`先进先出（FIFO）`：淘汰最先加入缓存的数据。这种策略比较简单，但可能会淘汰掉仍然高频访问的数据。`基于时间的过期策略`：为每个缓存项设置一个过期时间，一旦过期就从缓存中移除。这种策略适合于那些数据访问模式随时间变化较大的应用。

然后我们还可以监控内存使用情况，并根据当前的内存压力动态调整缓存的大小。当检测到内存使用接近上限时，可以主动减少缓存中的数据项，比如通过删除访问频率较低的项或者最早加入缓存的项。

如果单个节点的内存容量不足以支持当前的缓存需求，可以考虑将服务水平扩展到多个节点。通过分布式缓存方案，如Redis或Memcached，将缓存数据分布在多个服务器上，可以有效缓解单个服务器内存不足的问题。

内存和缓存监控
定期监控内存和缓存的使用情况，这对于早期发现潜在的内存不足问题非常关键。通过监控，我们可以及时调整缓存策略或进行资源扩展，以防止系统因内存耗尽而出现性能问题或崩溃。

使用磁盘备份
对于那些不经常访问但仍然需要保留的数据，可以考虑将其从内存中移动到磁盘上。虽然这会增加访问这部分数据的延迟，但可以作为一种权衡，以确保系统的稳定性和响应性。

通过实施上述策略，我能够确保即使在内存受限的情况下，也能有效管理缓存，并保持系统的高性能和稳定运行。这需要对系统的运行状况有持续的监控和调整，以适应不断变化的负载和数据访问模式。

## 你说你使用了Redis缓存，那你是怎么保证缓存和数据库的一致性的？

保证缓存（如Redis）和数据库之间的一致性是设计高可用系统时的一个重要挑战。为了解决这个问题，我采用了几种策略来尽量减少缓存与数据库之间数据不一致的情况。以下是一些常见的方法：

### 1. 缓存更新策略

- **缓存失效（Cache Invalidation）**：当数据库更新时，立即删除缓存中的相关数据。这样，下一次读取时会从数据库加载最新数据并更新缓存。这种方法简单直接，但可能会导致短暂的数据不一致（在缓存被清除和新数据被缓存这段时间内）。
- **写入时更新缓存（Write-Through Caching）**：在数据库更新的同时更新缓存。这种策略可以确保缓存总是最新的，但可能会稍微增加写操作的延迟。
- **延迟双写（Asynchronous Dual Writing）**：先更新数据库，然后异步更新缓存。这可以减少对前端操作的影响，但需要仔细处理异步操作失败的情况。

### 2. 使用事务确保一致性

在某些场景下，可以利用数据库的事务功能来保证数据库操作和缓存更新之间的一致性。例如，使用数据库事务包装数据库的写操作和缓存的失效/更新操作，确保它们要么都成功，要么都不发生。

### 3. 一致性哈希

一致性哈希可以用来保证在使用多个缓存节点的情况下，同一个键总是映射到相同的缓存节点。这对于维护不同节点之间的缓存一致性非常有用。

### 4. 缓存穿透策略

为了防止缓存失效后大量请求直接打到数据库，可能会采用缓存穿透策略，如设置空值缓存、布隆过滤器等，来避免这种情况。

### 5. 定期同步/校验

通过后台服务定期比较缓存与数据库的数据，对不一致的数据进行同步。这种方法适用于对实时性要求不是很高的数据。

### 实践案例

在我的项目中，我主要采用了缓存失效和写入时更新缓存的策略。具体来说，每当数据被更新时，我会同时更新数据库和Redis缓存。如果因为某些原因导致缓存更新失败，我会记录这次操作并通过后台进程尝试重新同步这部分数据，确保缓存和数据库最终一致。

为了减轻对数据库的直接访问压力，我还实现了查询时的缓存穿透策略，确保对于不存在的数据查询，通过在缓存中设置短暂的空值来避免频繁查询数据库。

通过这些策略的综合应用，我能够在保证系统性能的同时，最大程度地保证了缓存与数据库之间的一致性。

## 你说你使用了Redis缓存，那你是怎么保证缓存的高可用性的？

为了保证Redis缓存的高可用性，我采用了以下几种策略：

### 1. 主从复制

我使用了Redis的主从复制功能，将主节点的数据复制到多个从节点上。这样，即使主节点出现故障，从节点可以接管服务并继续提供缓存服务。我还会定期监控主从节点的状态，确保主从复制的正常运行。

### 2. 哨兵模式

我还使用了Redis的哨兵模式，通过哨兵来监控主从节点的状态，并在主节点故障时自动进行故障转移。这样可以实现自动化的故障恢复，提高了系统的可用性。

### 3. 集群模式

对于大规模的缓存集群，我会使用Redis的集群模式，将数据分片存储在多个节点上，提高了系统的扩展性和容错能力。

### 4. 数据持久化

我会定期对Redis的数据进行持久化，以防止数据丢失。我会使用Redis的RDB和AOF两种持久化方式，确保数据的安全性。

### 5. 监控和报警

我会使用监控系统对Redis的状态进行实时监控，并设置报警规则，及时发现并处理潜在的故障。

通过这些策略的综合应用，我能够保证Redis缓存的高可用性，确保系统的稳定运行。

## 

