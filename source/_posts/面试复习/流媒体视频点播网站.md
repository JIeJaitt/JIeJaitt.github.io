---
title: 流媒体视频点播网站
excerpt: 
abbrlink: 9fd5a35f
toc: true
date: 2023-03-08 11:46:28
categories: 期末考试
tags: 期末考试
sticky:
---

https://blog.csdn.net/weixin_52723461/article/details/120277314?csdn_share_tail=%7B%22type%22:%22blog%22,%22rType%22:%22article%22,%22rId%22:%22120277314%22,%22source%22:%22weixin_52723461%22%7D

https://coding.imooc.com/class/227.html#Anchor

代码仓库：https://github.com/JIeJaitt/goStreaming-on-demand-services

个人优势；不限城市可以立即到岗提前入职；热爱开源熟悉Github仓库协作流程

<!-- more -->

## 数据表是怎么实现的

- 用户表就是用户ID，用户登录名和用户密码
- 视频表就是视频ID，作者ID，视频名称，视频创建时间，视频展示时间
- 评论表就是评论ID，视频ID，作者ID，评论内容，评论时间
- session表就是sessionID，TTL，登录名

## 那你是怎么添加、删除用户，或者是视频的呢

主要是通过Go语言自带的数据库操作包database/sql库来操作数据库，用db.prepare()方法来预编译SQL语句，然后用db.exec把从请求头里面获取的一些包括比如用户id，用户名，登录密码之类的直接写入数据库

## session在什么时候使用

一开始系统启动的时候我们就把所有的session全部读到内存里面去，然后我们通过对一个简单的中间件，劫持所有的serverHTTP，对其进行session的校验，可以的话我们才进行后续的操作，否则就直接返回一个需要登录或者注册的信息

## 为什么用sync.map而不是map

首先就是性能比自己用 Mutex/RWMutex + Map好，里面是读写map，各自有一套key，但是映射了同个value，读map没有命中才去操作写map，miss次数多了，写map就会替代变成新的读map

而且session主要是一个频繁读取的一个性质，所以我们用sync.map来实现高频访问用户的Session数据的缓存

因为我主要是用来做高频访问用户的Session数据的缓存，sync.Map是Go语言提供的一种并发安全的数据结构，它可以在多个goroutine并发访问的情况下保证数据的一致性和安全性。而map在并发访问时需要加锁来保证数据的一致性，这样会增加额外的开销，而sync.Map内部已经实现了并发安全的机制，可以更好地满足高并发场景下的需求。

如果在并发访问的情况下不加锁，则会导致数据不一致的问题，而sync.Map可以避免这个问题，因此我选择了sync.Map来实现高频访问用户的Session数据的缓存。

sync.Map的使用也比较简单，可以直接通过Load、Store、Delete等方法来操作数据，与map加mutex的方式相比减少啦加锁对性能的一些损耗，因为sync.Map内部采用了一些优化的使得可以无锁读read map。

如果多个携程（协程）同时读取一个共享的数据结构，可能会引发以下问题：

1. 竞态条件（Race Conditions）：当多个携程同时读取共享的数据结构时，由于读取操作不会改变数据的状态，可能会导致竞态条件。竞态条件指的是多个携程以不可预测的方式相互干扰，从而导致程序出现错误的结果。例如，如果一个携程正在读取数据时，另一个携程可能会修改该数据，导致读取到的数据不一致或无效。
2. 数据不一致性：由于多个携程同时读取共享的数据结构，可能会导致数据不一致性的问题。当一个携程正在读取数据时，另一个携程可能在此期间修改了数据，导致读取到的数据不是最新的或不符合预期。
3. 死锁（Deadlock）：如果多个携程在读取共享数据时使用了互斥锁或其他同步机制，可能会发生死锁。死锁指的是多个携程互相等待对方释放资源，导致程序无法继续执行。

为了避免这些问题，可以采取以下措施：

1. 使用互斥锁（Mutex）或其他同步机制：在读取共享数据之前，使用互斥锁或其他同步机制对数据进行保护，确保同时只有一个携程可以读取数据。
2. 使用读写锁（ReadWrite Lock）：如果允许多个携程同时读取数据，但只有一个携程可以进行写操作，可以使用读写锁来实现。读写锁允许多个携程同时读取数据，但在写操作时会独占锁，确保数据的一致性。
3. 使用线程安全的数据结构：选择线程安全的数据结构可以避免多个携程同时读取共享数据时的竞态条件和数据不一致性问题。
4. 使用消息传递机制：通过消息传递机制，将共享数据拷贝给每个携程的私有副本，避免多个携程直接读取共享数据。这样可以避免竞态条件和数据不一致性问题，但需要考虑数据复制的开销。

总之，要正确处理多个携程同时读取共享数据的情况，需要使用适当的同步机制和数据结构，以及考虑并发操作可能导致的问题。

## 调度器模块是怎么实现的

调度器模块就是通过一个taskrunner来实现的，主要是包括三个channel，一个控制通道，一个数据通道和一个错误通道，控制通道主要是用来控制taskrunner的启动和停止，数据通道主要是用来传递数据，错误通道主要是用来传递错误信息，然后通过一个select来监听这三个通道，然后根据不同的通道来进行不同的操作，比如说如果是控制通道的话，就会根据控制通道的信息来进行启动或者停止taskrunner，如果是数据通道的话，就会根据数据通道的信息来进行数据的处理，如果是错误通道的话，就会根据错误通道的信息来进行错误的处理。

我们把要删除的视频的id我们先只加入到这个data通道里面，然后我们通过一个大的timer来定时，每次启动timer的时候，已经存在datachannel里面的视频做一个删除，否则我们就不进行删除操作


## 我看你说你测了QPS，怎么测的？最高能承受多少QPS？

本来我是想用Go语言自带的Benchmark来做基准测试的，但是后面我找到一个更方便的http压测工具————wrk，我就用wrk进行压测了，没有测过最高QPS，1000QPS的系统在一段时间内被100个左右的人同时使用了应该没问题，我当时觉得够了，而且我的系统还不完善，后面可能考虑加入redis之类的，性能应该能提升更多，而且视频网站的话我们还可以做本地缓存，这样用户体验会更好。

对于每种测试场景，我都设置了相同的压测参数，例如：

- 持续时间：2分钟
- 并发用户数：100
- 每秒请求次数（RPS）逐步提升：从100开始，每20秒增加100，直至系统达到其极限或保持一定的QPS水平。

```bash
wrk -t12 -c400 -d30s http://127.0.0.1:8080/api/session
```

## 你说你使用使用 sync.Map 在内存中缓存高频访问用户的 Session数据，那假如内存不够用了怎么办？

1、缓存淘汰之类的，`最近最少使用（LRU）`：淘汰最长时间未被访问的数据。这要求跟踪每个缓存项的访问历史，淘汰那些最少被访问的项。`先进先出（FIFO）`：淘汰最先加入缓存的数据。这种策略比较简单，但可能会淘汰掉仍然高频访问的数据。`基于时间的过期策略`：为每个缓存项设置一个过期时间，一旦过期就从缓存中移除。这种策略适合于那些数据访问模式随时间变化较大的应用。
2、然后我们还可以监控内存使用情况，并根据当前的内存压力动态调整缓存的大小。当检测到内存使用接近上限时，可以主动减少缓存中的数据项，比如通过删除访问频率较低的项或者最早加入缓存的项。
3、如果单个节点的内存容量不足以支持当前的缓存需求，可以考虑将服务水平扩展到多个节点。通过分布式缓存方案，如Redis或Memcached，将缓存数据分布在多个服务器上，可以有效缓解单个服务器内存不足的问题。
3、内存和缓存监控
定期监控内存和缓存的使用情况，这对于早期发现潜在的内存不足问题非常关键。通过监控，我们可以及时调整缓存策略或进行资源扩展，以防止系统因内存耗尽而出现性能问题或崩溃。
4、使用磁盘备份
对于那些不经常访问但仍然需要保留的数据，可以考虑将其从内存中移动到磁盘上。虽然这会增加访问这部分数据的延迟，但可以作为一种权衡，以确保系统的稳定性和响应性。

通过实施上述策略，我能够确保即使在内存受限的情况下，也能有效管理缓存，并保持系统的高性能和稳定运行。这需要对系统的运行状况有持续的监控和调整，以适应不断变化的负载和数据访问模式。


## 说一下session、cookie、token的区别

`Session`、`Cookie`和`Token`是在网络应用中处理用户状态和身份验证的三种不同技术。它们各自有不同的用途和工作机制：

- **存储位置**：Cookie存储在客户端浏览器上，Session信息存储在服务器上，Token虽然由服务器生成但通常存储在客户端。
- **安全性**：Token设计用于在不同服务间安全传递信息，通常具有更好的安全特性（如可以加密）。Session ID如果被截获，攻击者可能会进行会话劫持。Cookie也可能遭到CSRF（跨站请求伪造）等攻击。
- **状态**：Session是有状态的，服务器需要存储会话数据；而Token通常用于实现无状态认证机制，服务器不需要保存用户状态。

使用这些技术时，应根据应用的安全需求、性能考虑以及用户体验来选择最合适的方案。

## 令牌桶算法的实现

## 调度器怎么实现的